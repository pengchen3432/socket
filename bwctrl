#!/bin/sh /etc/rc.common
# Copyright (C) 2017 Grandstream Networks, Inc
. /lib/functions.sh
. /lib/functions/network.sh
. /lib/functions/gs_platform.sh


START=99
SERVICE=bwctrl
USE_PROCD=1

#lock(noblock) bwctrl
scriptname=$(basename $0)
lock="/var/run/${scriptname}"
stop_hard_accele=0
exec 200>$lock
flock -n 200 || exit 1
#unlock after bwctrl exit

[ ! -d /var/bwctrl ] && mkdir /var/bwctrl
CLIENTFILE=/var/bwctrl/.clientdict
echo "" > $CLIENTFILE

boot() {
    logger -t $SERVER -p daemon.info "bwctrl booting"
    rc_procd start_service
}

#(key) returns val and increments it
# Beacuse the portalqos will use TC classid 1~640, so bwctrl classid classid should start from 650
clientcount() {
    DICTFILE=$CLIENTFILE
    DICT=$(cat ${DICTFILE})
    local count=650
    if [[ -z "$DICT" ]] ; then
        count=650
        DICT="$1,$count"
        echo $DICT > ${DICTFILE}
        echo $count
        return 0
    fi

    local temp=""
    for n in ${DICT}; do
        key=${n%,*}
        val=${n#*,}
        if [[ "$key" == "$1" ]] ; then

            count=$(( $val + 1))
            if [[ -z "$temp" ]] ; then
                temp="${key},$count"
            else
                temp="$temp ${key},$count"
            fi
        else
            if [[ -z "$temp" ]] ; then
                temp="$n"
            else
                temp="$temp $n"
            fi
        fi
    done
    if [[ $count == 650 ]] ; then
        DICT="$temp ${1},650"
    else
        DICT=$temp
    fi
    echo $DICT > ${DICTFILE}
    echo $count
}


# (RATE)
convert_bitrate() {

    local bitrate="$1"
    if [ ! $bitrate ]; then
        bitrate=0
    fi

    if [ -n "$( echo $bitrate | grep -F -e "Mbps" )" ]; then
        bitrate="${bitrate%%Mbps}"
        bitrate=$((bitrate * 1000000))
    elif [ -n "$( echo $bitrate | grep -F -e "Kbps" )" ]; then
        bitrate="${bitrate%%Kbps}"
        bitrate=$((bitrate * 1000))
    fi

    echo "$bitrate"
}

# (DEV)
clearDev(){
    ###### remove old config ######
    tc qdisc del dev $1 root         2> /dev/null
    tc qdisc del dev $1 ingress      2> /dev/null
}

clearAll(){
     for f in /sys/devices/virtual/net/ath* ; do
        if [ -e "$f" ] ; then
            clearDev $(basename $f)
        fi
     done
}

devExist(){
    result=`iwconfig $1|grep "Bit Rate"|awk -F: '{print $2}'|awk '{print $1}'`

    if [ "$result" != "0" ];then
        logger -t $SERVER -p daemon.info "bwctrl devExist \$1:$1  Bit Rate:$result"
        return 0
    else
        logger -t $SERVER -p daemon.info "bwctrl devExist \$1:$1  Bit Rate:$result"
        return 1
    fi
}

waitDev(){
    cnt=0
    while [ "$cnt" -lt 5 ]
    do
        devExist $1
        if [ "$?" = "0" ];then
            return
        fi
        cnt=`expr $cnt + 1`
        sleep 1
    done
    logger -t $SERVER -p daemon.info "bwctrl *** waitDev:$1 not exist ***"
}

# (DEV, DOWN, UP)
addSSID(){
    local DEV="$1"
    local DOWN="$2"
    local UP="$3"
    clearDev "$DEV"
    CLIENT=$(clientcount $DEV) # for consistant flowids
    ###### DOWN - AP to Client #######

    local if_mode=`uci get wireless.${DEV}.mode`
    if [ "x$if_mode" = "xsta" ];then
        return 0
    fi

    waitDev $DEV
    #if this returns an error it's already setup
    local t="$(tc qdisc add dev $DEV root handle 1:0 htb 2>&1)"
    if [ -n "$t" ] ; then
        return 0
    fi

    if [ $DOWN -gt 0 ]; then
        tc class add dev $DEV parent 1:0 classid 1:$CLIENT htb rate $DOWN burst $(($DOWN/10)) cburst $(($DOWN/10)) 2>/dev/null

        #default flow for unclassified packets (need the highest prio to be check LAST)
        tc filter add dev $DEV parent 1:0 protocol ip prio 99 u32 match ip dst 0.0.0.0/0 flowid 1:$CLIENT 2>/dev/null
        tc filter add dev $DEV parent 1:0 protocol ipv6 prio 109 u32 match ip6 dst any flowid 1:$CLIENT 2>/dev/null
    fi

    ###### UP - Client to AP ######
    tc qdisc add dev $DEV handle ffff: ingress 2>/dev/null
    if [ $UP -gt 0 ]; then

        tc filter add dev $DEV parent ffff: protocol ip prio 99 \
            u32 match ip src 0.0.0.0/0 police rate $UP \
            burst $(($UP/10)) drop flowid :1 2>/dev/null
        tc filter add dev $DEV parent ffff: protocol ipv6 prio 109 \
            u32 match ip6 src any police rate $UP \
            burst $(($UP/10)) drop flowid :1 2>/dev/null
    fi

}

# (DEV)
initClient(){
    local DEV=$1

    local if_mode=`uci get wireless.${DEV}.mode`
    if [ "x$if_mode" = "xsta" ];then
        return 0
    fi

    waitDev $DEV
    ###### set up root and default class if a ssid rule hasn't already!
    #if this returns an error it's already setup
    local t="$(tc qdisc add dev $DEV root handle 1:0 htb 2>&1)"
    if [ -n "$t" ] ; then
        return 0
    fi

    #this just is the freeforall rate, should be the link speed.
    local MAXRATE=900000000

    CLIENT=$(clientcount $DEV)
    tc class add dev $DEV parent 1:0 classid 1:$CLIENT htb rate $MAXRATE burst $(($MAXRATE/10)) cburst $(($MAXRATE/10)) 2>/dev/null

    #default flow for unclassified packets (need the highest prio to be check LAST)
    tc filter add dev $DEV parent 1:0 protocol ip prio 99 u32 match ip dst 0.0.0.0/0 flowid 1:$CLIENT 2>/dev/null
    tc filter add dev $DEV parent 1:0 protocol ipv6 prio 109 u32 match ip6 dst any flowid 1:$CLIENT 2>/dev/null

    ###### Add the ingress qdisc
    tc qdisc add dev $DEV handle FFFF:0 ingress 2>/dev/null
}

# (DEV, ID, DOWN, UP)
addClient(){
    local DEV=$1
    local ID=$2
    local DOWN=$3
    local UP=$4

    local if_mode=`uci get wireless.${DEV}.mode`
    if [ "x$if_mode" = "xsta" ];then
        return 0
    fi

    waitDev $DEV
    initClient $DEV

    CLIENT=$(clientcount $DEV)
    ###### DOWN - from AP to client #######
    if [ $DOWN -gt 0 ]; then
        tc class  add dev $DEV parent 1:0 classid 1:$CLIENT htb rate $DOWN burst $(($DOWN/10)) cburst $(($DOWN/10)) 2>/dev/null

        if [ ${ID/:/} == $ID ] ; then
            tc filter add dev $DEV parent 1:0 protocol ip prio 2 u32 \
                match ip dst $ID flowid 1:$CLIENT 2>/dev/null
        else
            tc filter add dev $DEV parent 1:0 protocol ipv6 prio 12 u32 \
                match ip6 dst $ID flowid 1:$CLIENT 2>/dev/null
        fi
    fi

    if [ $UP -gt 0 ]; then
        ###### UP - from client to AP ######
        #local HANDLE=`printf %x $((65535-$CLIENT))`
        if [ ${ID/:/} == $ID ] ; then
            tc filter add dev $DEV parent FFFF: protocol ip prio 2 u32 \
                match ip src $ID police rate $UP burst $(($UP/10)) drop flowid :1 2>/dev/null
        else
            tc filter add dev $DEV parent FFFF: protocol ipv6 prio 12 u32 \
                match ip6 src $ID police rate $UP burst $(($UP/10)) drop flowid :1 2>/dev/null
        fi
    fi
}

addMacClient(){
    local DEV=$1
    local ID=$2
    local DOWN=$3
    local UP=$4

    local if_mode=`uci get wireless.${DEV}.mode`
    if [ "x$if_mode" = "xsta" ];then
        return 0
    fi

    waitDev $DEV
    initClient $DEV

    CLIENT=$(clientcount $DEV)


    #validate the mac address
    local d1="$( echo "$( echo $ID | cut -c 3 )" | grep -F -e "$( echo $ID | cut -c 6  )" 2>/dev/null)"
    local d0="$( echo "$( echo $ID | cut -c 9 )" | grep -F -e "$( echo $ID | cut -c 12 )" 2>/dev/null)"
    local  d="$( echo $d0 | grep -F -e $d1 2>/dev/null)"
           d="$( echo $d  | grep -F -e "$( echo $ID | cut -c 15 )" 2>/dev/null )"
    if [ -z "$d" ] ; then
        logger -t $SERVER -p daemon.info "bwctrl Bad MAC Address: $ID"
        return 0
    fi

    #break up each byte
    local m01="$(echo $ID | cut -d $d -f 1)$(echo $ID | cut -d $d -f 2)"
    local m23="$(echo $ID | cut -d $d -f 3)$(echo $ID | cut -d $d -f 4)"
    local m45="$(echo $ID | cut -d $d -f 5)$(echo $ID | cut -d $d -f 6)"


    ###### DOWN - from AP to client ######
    if [ $DOWN -gt 0 ]; then
        tc class  add dev $DEV parent 1:0 classid 1:$CLIENT htb rate $DOWN burst $(($DOWN/10)) cburst $(($DOWN/10)) 2>/dev/null

        tc filter add dev $DEV parent 1:0 protocol ip prio 1 u32 \
            match u16 0x0800 0xFFFF at -2 \
            match u32 0x${m23}${m45} 0xFFFFFFFF at -12 \
            match u16 0x${m01} 0xFFFF at -14 \
            flowid 1:$CLIENT 2>/dev/null

        tc filter add dev $DEV parent 1:0 protocol ip prio 1 u32 \
            match u16 0x0800 0xFFFF at -2 \
            match u16 0x${m45} 0xFFFF at -4 \
            match u32 0x${m01}${m23} 0xFFFFFFFF at -8 \
            flowid 1:$CLIENT 2>/dev/null

        tc filter add dev $DEV parent 1:0 protocol ipv6 prio 11 u32 \
            match u16 0x86dd 0xFFFF at -2 \
            match u32 0x${m23}${m45} 0xFFFFFFFF at -12 \
            match u16 0x${m01} 0xFFFF at -14 \
            flowid 1:$CLIENT 2>/dev/null

        tc filter add dev $DEV parent 1:0 protocol ipv6 prio 11 u32 \
            match u16 0x86dd 0xFFFF at -2 \
            match u16 0x${m45} 0xFFFF at -4 \
            match u32 0x${m01}${m23} 0xFFFFFFFF at -8 \
            flowid 1:$CLIENT 2>/dev/null
    fi

    ###### UP - from client to AP ######
    #local HANDLE=`printf %x $((65535-$CLIENT))`
    if [ $UP -gt 0 ]; then
        tc filter add dev $DEV parent FFFF: protocol ip prio 1 u32 \
            match u16 0x0800 0xFFFF at -2 \
            match u16 0x${m45} 0xFFFF at -4 \
            match u32 0x${m01}${m23} 0xFFFFFFFF at -8 \
            police rate $UP burst $(($UP/10)) drop flowid :1 2>/dev/null

        tc filter add dev $DEV parent FFFF: protocol ip prio 1 u32 \
            match u16 0x0800 0xFFFF at -2 \
            match u32 0x${m23}${m45} 0xFFFFFFFF at -12 \
            match u16 0x${m01} 0xFFFF at -14 \
            police rate $UP burst $(($UP/10)) drop flowid :1 2>/dev/null

        tc filter add dev $DEV parent FFFF: protocol ipv6 prio 11 u32 \
            match u16 0x86dd 0xFFFF at -2 \
            match u16 0x${m45} 0xFFFF at -4 \
            match u32 0x${m01}${m23} 0xFFFFFFFF at -8 \
            police rate $UP burst $(($UP/10)) drop flowid :1 2>/dev/null

        tc filter add dev $DEV parent FFFF: protocol ipv6 prio 11 u32 \
            match u16 0x86dd 0xFFFF at -2 \
            match u32 0x${m23}${m45} 0xFFFFFFFF at -12 \
            match u16 0x${m01} 0xFFFF at -14 \
            police rate $UP burst $(($UP/10)) drop flowid :1 2>/dev/null
    fi
}

start_service() {
    logger -t $SERVER -p daemon.info "bwctrl Starting..."

    procd_open_instance
    procd_set_param command /usr/sbin/service_placeholder --bwctrl
    #procd_set_param file /etc/config/bwctrl

    #we need to setup ssids first now
    config_ssid() {
        local enabled ruletype id dev down up

        config_get enabled "$1" "enabled"
        [ "$enabled" != '1' ] && return 0

        config_get ruletype "$1" "type"
        [ "$ruletype" != "ssid" ] && return 0

        config_get id "$1" "id"
        config_get up "$1" "urate"
        config_get down "$1" "drate"

        up=$(convert_bitrate $up)
        down=$(convert_bitrate $down)

        config_list_foreach $1 dev addSSID $down $up

        stop_hard_accele=1
    }

    config_client() {
        local enabled ruletype id dev zone down up

        config_get enabled "$1" "enabled"
        [ "$enabled" != '1' ] && return 0

        config_get ruletype "$1" "type"
        [ $ruletype == "ssid" ] && return 0

        config_get id "$1" "id"
        config_get up "$1" "urate"
        config_get down "$1" "drate"
        up=$(convert_bitrate $up)
        down=$(convert_bitrate $down)

        if [ $ruletype == "ip" ] ; then
            config_list_foreach $1 dev addClient $id $down $up
        elif [ $ruletype == "mac" ] ; then
            config_list_foreach $1 dev addMacClient $id $down $up
        fi

        stop_hard_accele=1
    }

    clearAll

    config_load "bwctrl"
    config_foreach config_ssid "bwctrl-rule"
    config_foreach config_client "bwctrl-rule"

    procd_close_instance
    ubus call portalqos start_qos

    if [ $stop_hard_accele -eq 1 ]; then
        /etc/init.d/qca-nss-ecm stop
    fi
}

stop_service() {
    local pid
    logger -t $SERVER -p daemon.info "bwctrl Stopping..."

    clearAll
    ubus call portalqos stop_qos
    pid="$(ps | grep service_placeholder | grep -v grep | grep bwctrl | cut -d' ' -f2)"
    kill -9 $pid

    /etc/init.d/qca-nss-ecm start
}

reload_service() {
    logger -t $SERVER -p daemon.info "bwctrl Stopping..."
    pid="$(ps | grep service_placeholder | grep -v grep | grep bwctrl | cut -d' ' -f2)"
    kill -9 $pid
    /etc/init.d/qca-nss-ecm start
    start_service
}

service_triggers() {
    procd_add_reload_trigger "bwctrl" "wireless"
}



